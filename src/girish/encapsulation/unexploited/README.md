# Unexploited Encapsulation

Unexploited Encapsulation terjadi ketika kita tidak memanfaatkan encapsulation yang sudah ada di dalam class. Daripada menggunakan method dan behavior yang sudah ada di object, kita malah mengakses data mentah dan melakukan operasi di luar class.

Smell ini mirip dengan Feature Envy dari Martin Fowler, dimana code lebih sering mengakses data dari object lain daripada menggunakan behavior object itu sendiri.

### Penyebab Smell

- **Data-focused thinking**: Developer berpikir dalam bentuk data dan operasi terpisah, bukan object dengan behavior.
- **Lack of understanding**: Developer tidak memahami behavior yang sudah tersedia di class yang ada.
- **Copy-paste programming**: Developer menyalin logic yang seharusnya sudah ada di class lain.
- **Incomplete refactoring**: Behavior belum di-move ke class yang tepat setelah data di-extract.

### Contoh

#### Masalah

Perhatikan package `before`. Terdapat class [ShapePrinter.java](before/ShapePrinter.java) yang menerima parameter `String shape` dan `int size`, lalu melakukan operasi berdasarkan string tersebut. Logic untuk menentukan bentuk shape ada di luar class Shape itu sendiri.

```java
public class ShapePrinter {
    public void print(String shape, int size){
        if(shape.equalsIgnoreCase("square")){
            // print square logic
        } else if(shape.equalsIgnoreCase("triangle")){
            // print triangle logic
        }
    }
}
```

**Masalah yang terjadi:**
1. Logic shape terpisah dari representasi shape itu sendiri
2. Jika ada shape baru, harus modify method `print()` (melanggar Open/Closed Principle)
3. Tidak memanfaatkan encapsulation - shape hanya sebagai string primitif
4. Duplicate logic - ada juga [CharNeededCounter.java](before/CharNeededCounter.java) yang melakukan hal serupa dengan if-else

#### Penyelesaian

Pada package `after`, dibuat hierarchy class Shape dengan behavior yang proper. Setiap shape menjadi object tersendiri dengan method `print()` dan `charNeeded()`. Factory pattern digunakan untuk membuat shape dari string.

```java
// Shape sebagai abstraction dengan behavior
public abstract class Shape {
    protected int size;
    public abstract void print();
    public abstract int charNeeded();
}

public class Square extends Shape {
    public Square(int size) {
        this.size = size;
    }
    
    @Override
    public void print() {
        // square printing logic
    }
    
    @Override
    public int charNeeded() {
        return size * size;
    }
}

public class Triangle extends Shape {
    // similar implementation
}

// Factory untuk create shape
public class ShapeFactory {
    public Shape create(String shape, int size) throws Exception {
        if(shape.equalsIgnoreCase("triangle")) {
            return new Triangle(size);
        } else if (shape.equalsIgnoreCase("square")) {
            return new Square(size);
        }
        throw new Exception("invalid shape");
    }
}
```

**Keuntungan setelah refactoring:**
1. Logic shape terkapsulasi di dalam class Shape itu sendiri
2. Mudah menambah shape baru tanpa mengubah existing code (Open/Closed Principle)
3. Polymorphism memungkinkan runtime behavior
4. Single Responsibility - setiap shape bertanggung jawab untuk behavior-nya sendiri
5. Lebih mudah di-test - setiap shape bisa di-test terpisah

**Penggunaan setelah refactoring:**
```java
ShapeFactory factory = new ShapeFactory();
Shape square = factory.create("square", 5);
square.print();  // Memanfaatkan encapsulation
int chars = square.charNeeded();  // Behavior ada di object
```

### When to Ignore

Smell ini tidak perlu di-refactor bila:
- Logic memang sederhana dan tidak akan berkembang
- Refactoring akan membuat code menjadi over-engineered
- String-based approach memang lebih sesuai untuk konteks tertentu (misalnya configuration)

